<!DOCTYPE html>
<html lang="zh-Hant">
  <head>
    <meta charset="UTF-8" />
    <title>å…¬æ–‡æ™‚æ•ˆè¨ˆç®—å™¨</title>
    <script src="https://unpkg.com/vue@3"></script>
    <link
      href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/flatpickr/dist/themes/material_orange.css"
    />
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
    <script src="https://cdn.jsdelivr.net/npm/flatpickr/dist/l10n/zh.js"></script>
    <style>
      html {
        overflow-y: scroll;
      }
      .flatpickr-calendar {
        left: 50% !important;
        transform: translateX(-50%) !important;
      }

      /* Enhanced scrollbar style for visual inset */
      .details-scrollbar::-webkit-scrollbar {
        width: 14px;
      }
      .details-scrollbar::-webkit-scrollbar-track {
        background: transparent;
      }
      .details-scrollbar::-webkit-scrollbar-thumb {
        background-color: #fbbf24;
        border-radius: 10px;
        border: 4px solid transparent;
        background-clip: content-box;
      }
      .details-scrollbar::-webkit-scrollbar-thumb:hover {
        background-color: #f59e0b;
      }

      .help-button {
        position: fixed;
        bottom: 20px;
        right: 20px;
        z-index: 1000;
      }
      .help-modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.65);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1050;
        padding: 1rem;
      }
      .help-modal-card {
        background-color: white;
        border-radius: 1.5rem;
        box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1),
          0 10px 10px -5px rgba(0, 0, 0, 0.04);
        width: 100%;
        max-width: 680px;
        display: flex;
        flex-direction: column;
        max-height: 85vh;
        border: 4px solid #fbcfe8;
      }
      .help-modal-header {
        padding: 1.25rem 2rem 0.75rem 2rem; /* py-5 px-8 pb-3 */
        border-bottom: 1px solid #e5e7eb; /* border-gray-200 */
      }
      .help-modal-header h2 {
        font-size: 1.75rem;
        font-weight: 700;
        color: #db2777;
        text-align: center;
      }
      .help-modal-content {
        padding: 1.25rem 1rem 1.5rem 2rem; /* Adjusted for scrollbar inset */
        overflow-y: auto;
        flex-grow: 1;
        line-height: 1.8;
      }
      .help-modal-content h4 {
        font-size: 1.25rem;
        font-weight: 700;
        color: #c026d3;
        margin-bottom: 0.75rem;
        margin-top: 1.25rem;
      }
      .help-modal-content h4:not(:first-child) {
        padding-top: 1.25rem;
        border-top: 1px solid #f3f4f6; /* Light separator */
      }
      .help-modal-content h4:first-child {
        margin-top: 0.25rem;
      }
      .help-modal-content p,
      .help-modal-content li {
        font-size: 1rem;
        color: #374151;
        margin-bottom: 0.25rem;
      }
      .help-modal-content p:last-child,
      .help-modal-content ul:last-child li:last-child {
        margin-bottom: 0;
      }
      .help-modal-content strong {
        color: #9d174d;
        font-weight: 600;
      }
      .help-modal-content ul {
        list-style-type: disc;
        padding-left: 1.5rem;
        margin-bottom: 1rem;
      }
      .help-modal-content ul ul {
        list-style-type: circle;
        margin-top: 0.375rem;
        margin-bottom: 0.6rem;
        padding-left: 1.25rem;
      }
      .help-modal-content li ul li {
        margin-bottom: 0.375rem;
        font-size: 1rem;
      }
      .help-modal-content code {
        background-color: #f3f4f6;
        color: #be185d;
        padding: 0.125rem 0.375rem;
        border-radius: 0.25rem;
        font-size: 0.9em;
      }
      .help-modal-footer {
        padding: 1rem 2rem 1.25rem 2rem;
        border-top: 1px solid #e5e7eb;
      }
    </style>
  </head>
  <body class="bg-yellow-50 min-h-screen p-4 font-sans">
    <div id="app" class="max-w-3xl mx-auto">
      <header class="mb-6">
        <h1
          class="mt-10 text-4xl font-bold text-pink-600 text-center flex items-center justify-center gap-2"
        >
          ğŸ‰ å…¬æ–‡æ™‚æ•ˆè¨ˆç®—å™¨
        </h1>
      </header>

      <main>
        <section
          class="bg-white rounded-3xl shadow-xl p-6 space-y-6 border-4 border-pink-200"
        >
          <div>
            <label class="block text-lg font-semibold text-pink-700 mb-2"
              >ğŸ“Œ è¾¦ç†æƒ…å½¢ï¼š</label
            >
            <div class="grid grid-cols-2 gap-4">
              <button
                @click="setFormType('ä¾†æ–‡å­˜æŸ¥')"
                :class="buttonClass('ä¾†æ–‡å­˜æŸ¥')"
              >
                ğŸ“ ä¾†æ–‡å­˜æŸ¥
              </button>
              <button
                @click="setFormType('ä¾†æ–‡å‡½å¾©')"
                :class="buttonClass('ä¾†æ–‡å‡½å¾©')"
              >
                ğŸ“¬ ä¾†æ–‡å‡½å¾©
              </button>
              <button
                @click="setFormType('å‰µç°½å­˜æŸ¥')"
                :class="buttonClass('å‰µç°½å­˜æŸ¥')"
              >
                ğŸ“ å‰µç°½å­˜æŸ¥
              </button>
              <button
                @click="setFormType('å‰µç¨¿ç™¼æ–‡')"
                :class="buttonClass('å‰µç¨¿ç™¼æ–‡')"
              >
                ğŸ“¤ å‰µç¨¿ç™¼æ–‡
              </button>
            </div>
          </div>

          <div v-if="formType" class="space-y-5">
            <div>
              <label
                :for="formType + '-start'"
                class="block text-pink-700 font-semibold mb-1"
                >ğŸ• {{ labels[formType]?.start || 'èµ·å§‹æ™‚é–“' }}</label
              >
              <input
                :id="formType + '-start'"
                ref="startPicker"
                type="text"
                class="w-full border-2 border-pink-200 rounded-xl p-2 bg-white focus:ring-2 focus:ring-pink-400 outline-none"
              />
            </div>
            <div>
              <label
                :for="formType + '-end'"
                class="block text-pink-700 font-semibold mb-1"
                >âœ… {{ labels[formType]?.end || 'çµæŸæ™‚é–“' }}</label
              >
              <input
                :id="formType + '-end'"
                ref="endPicker"
                type="text"
                class="w-full border-2 border-pink-200 rounded-xl p-2 bg-white focus:ring-2 focus:ring-pink-400 outline-none"
              />
            </div>
            <div>
              <label
                for="manualHolidaysInput"
                class="block text-pink-700 font-semibold mb-1"
                >ğŸŒ§ é¡å¤–åœç­æ—¥ï¼ˆYYYY-MM-DDï¼Œä»¥é€—è™Ÿåˆ†éš”ï¼‰</label
              >
              <input
                id="manualHolidaysInput"
                type="text"
                v-model="manualHolidayInput"
                @input="handleManualHolidayInput"
                class="w-full border-2 border-yellow-300 rounded-xl p-2 bg-yellow-50 focus:ring-2 focus:ring-yellow-500 outline-none"
                placeholder="ä¾‹å¦‚ï¼š2025-08-01, 2025-09-20"
              />
            </div>
            <button
              @click="calculate"
              :disabled="!start || !end"
              class="w-full bg-pink-500 hover:bg-pink-600 text-white font-bold py-3 px-5 rounded-full shadow-lg transform hover:scale-105 transition disabled:opacity-50 disabled:cursor-not-allowed"
            >
              âœ¨ è¨ˆç®—æ™‚æ•ˆï¼
            </button>
          </div>
        </section>

        <section
          v-if="result !== null"
          class="mt-6 bg-green-100 border-l-8 border-green-400 rounded-2xl p-5 shadow-xl"
        >
          <h3 class="text-2xl font-bold text-green-800 mb-2">
            â± è™•ç†æ™‚æ•¸ï¼š{{ formattedTime }}
          </h3>
          <h3 class="text-2xl font-bold text-green-800">
            ğŸ“… æ›ç®—ç‚ºè™•ç†æ—¥æ•¸ï¼š{{ result }} æ—¥
          </h3>
        </section>

        <section
          v-if="dailyDetails.length > 0"
          class="mt-6 bg-blue-50 border-l-8 border-blue-300 rounded-2xl p-5 shadow-xl"
        >
          <h3 class="text-xl font-bold text-blue-700 mb-3">
            ğŸ•°ï¸ è™•ç†æ™‚æ•¸æ˜ç´°ï¼š
          </h3>
          <ul
            class="space-y-1.5 text-sm text-gray-800 max-h-60 overflow-y-auto details-scrollbar pr-2"
          >
            <li
              v-for="detail in dailyDetails"
              :key="detail.date + detail.reason"
              :class="['p-2 rounded-lg', detailTypeClass(detail.type)]"
            >
              <span class="font-semibold">{{ detail.date }}</span>:
              <span v-if="detail.type === 'work'"> {{ detail.reason }}</span>
              <span v-else> {{ detail.reason }}</span>
            </li>
          </ul>
        </section>

        <section class="mt-4 text-xs text-gray-600 space-y-1">
          <p
            v-if="initialCalendarLoadAttempted && Object.keys(calendarApiData).length > 0"
          >
            â„¹ï¸ å·²è¼‰å…¥ {{ Object.keys(calendarApiData).length }}
            ç­†æ”¿åºœè¡Œäº‹æ›†è³‡æ–™ã€‚
          </p>
          <p v-if="manualHolidays.length > 0">
            â„¹ï¸ å·²è¨­å®šé¡å¤–åœç­æ—¥å…± {{ manualHolidays.length }} ç­†ï¼š{{
            manualHolidays.join(', ') }}ï¼ˆå·²å„²å­˜æ–¼ç€è¦½å™¨ï¼‰ã€‚
          </p>
          <p v-if="missingYears.length > 0" class="text-red-600 font-semibold">
            âš ï¸ æ³¨æ„ï¼šç„¡æ³•è¼‰å…¥ {{ missingYears.join('ã€') }}
            å¹´ä¹‹æ”¿åºœè¡Œäº‹æ›†ï¼Œé€™äº›å¹´ä»½å°‡åƒ…ä¾é€±æœ«åˆ¤æ–·å·¥ä½œæ—¥ã€‚
          </p>
        </section>
      </main>

      <button
        @click="toggleHelpModal(true)"
        class="help-button bg-pink-500 hover:bg-pink-600 text-white font-bold py-3 px-4 rounded-full shadow-lg transition transform hover:scale-110 focus:outline-none focus:ring-2 focus:ring-pink-400 focus:ring-opacity-75"
      >
        ğŸ’¡<span class="hidden sm:inline ml-1">æ“ä½œèªªæ˜</span>
      </button>

      <div
        v-if="showHelpModal"
        class="help-modal-overlay"
        @click.self="toggleHelpModal(false)"
      >
        <div class="help-modal-card">
          <div class="help-modal-header">
            <h2>ğŸ’¡ æ“ä½œèªªæ˜ ğŸ’¡</h2>
          </div>
          <div class="help-modal-content details-scrollbar">
            <h4>ğŸ“„ é¸æ“‡è¾¦ç†æƒ…å½¢</h4>
            <p>é¦–å…ˆï¼Œè«‹æ ¹æ“šå…¬æ–‡é¡å‹ï¼Œåœ¨æœ€ä¸Šæ–¹çš„æŒ‰éˆ•é¸æ“‡ä¸€ç¨®ã€Œè¾¦ç†æƒ…å½¢ã€ï¼š</p>
            <ul>
              <li><strong>ğŸ“ ä¾†æ–‡å­˜æŸ¥ï¼š</strong>æ”¶æ–‡å¾Œç›´æ¥å­˜æŸ¥çš„æ¡ˆä»¶ã€‚</li>
              <li><strong>ğŸ“¬ ä¾†æ–‡å‡½å¾©ï¼š</strong>æ”¶æ–‡å¾Œéœ€è¦å‡½å¾©çš„æ¡ˆä»¶ã€‚</li>
              <li><strong>ğŸ“ å‰µç°½å­˜æŸ¥ï¼š</strong>è‡ªè¡Œå‰µç°½ä¸¦å­˜æŸ¥çš„æ¡ˆä»¶ã€‚</li>
              <li><strong>ğŸ“¤ å‰µç¨¿ç™¼æ–‡ï¼š</strong>è‡ªè¡Œå‰µç¨¿ä¸”éœ€è¦ç™¼æ–‡çš„æ¡ˆä»¶ã€‚</li>
            </ul>

            <h4>ğŸ“… è¨­å®šèµ·è¿„æ™‚é–“</h4>
            <p>é¸æ“‡è¾¦ç†æƒ…å½¢å¾Œï¼Œç•«é¢æœƒå‡ºç¾å°æ‡‰çš„èµ·è¿„æ™‚é–“æ¬„ä½ã€‚</p>
            <ul>
              <li>é»æ“Šæ¬„ä½è¼¸å…¥æ¡†ï¼Œå½ˆå‡ºæ—¥æœŸæ™‚é–“é¸æ“‡å™¨ã€‚</li>
              <li>
                è«‹é¸æ“‡å…¬æ–‡è¾¦ç†éç¨‹ä¸­çš„ã€Œèµ·å§‹æ™‚é–“ã€èˆ‡ã€ŒçµæŸæ™‚é–“ã€ï¼ˆæ¬„ä½åç¨±å°‡æ ¹æ“šé¸æ“‡çš„ã€Œè¾¦ç†æƒ…å½¢ã€å‹•æ…‹èª¿æ•´ï¼‰ã€‚
              </li>
              <li><strong>æ³¨æ„ï¼š</strong>çµæŸæ™‚é–“å¿…é ˆæ™šæ–¼èµ·å§‹æ™‚é–“ã€‚</li>
            </ul>

            <p><strong>èµ·å§‹æ™‚é–“ç¯€é»èªªæ˜ï¼š</strong></p>
            <ul>
              <li>
                <strong>ã€Œä¾†æ–‡å­˜æŸ¥ã€</strong>æˆ–<strong>ã€Œä¾†æ–‡å‡½å¾©ã€</strong>ï¼š
                <ul>
                  <li>èµ·å§‹æ™‚é–“ç‚ºã€Œæ”¶æ–‡ç™»è¨˜ã€çš„æ™‚é–“ã€‚</li>
                  <li>
                    è™•ç†æ™‚æ•ˆå°‡å¾<strong>æ”¶æ–‡æ¬¡æ—¥</strong> 08:00 é–‹å§‹è¨ˆç®—ã€‚
                  </li>
                </ul>
              </li>
              <li>
                <strong>ã€Œå‰µç°½å­˜æŸ¥ã€</strong>æˆ–<strong>ã€Œå‰µç¨¿ç™¼æ–‡ã€</strong>ï¼š
                <ul>
                  <li>èµ·å§‹æ™‚é–“ç‚ºã€Œé€å‡ºæ‰¿è¾¦å–®ä½ã€çš„æ™‚é–“ã€‚</li>
                  <li>è™•ç†æ™‚æ•ˆå°‡å¾<strong>èµ·å§‹æ™‚é–“</strong>é–‹å§‹è¨ˆç®—ã€‚</li>
                </ul>
              </li>
            </ul>

            <h4>ğŸŒ§ï¸ è¨­å®šé¡å¤–åœç­æ—¥ï¼ˆé¸å¡«ï¼‰</h4>
            <p>
              è‹¥åœ¨å…¬æ–‡è™•ç†æœŸé–“ï¼Œé‡åˆ°<strong>æ”¿åºœå…¬å‘Šçš„è‡¨æ™‚åœç­æ—¥</strong>ï¼ˆä¾‹å¦‚é¢±é¢¨å‡ï¼‰ï¼Œä½†é€™äº›æ—¥æœŸä¸¦æœªåŒ…å«åœ¨è‡ªå‹•è¼‰å…¥çš„æ”¿åºœè¡Œäº‹æ›†ä¸­æ™‚ï¼Œå¯ä»¥åœ¨æ­¤æ‰‹å‹•è¼¸å…¥ã€‚
            </p>
            <ul>
              <li>
                æ ¼å¼ç‚º
                <code>YYYY-MM-DD</code
                >ï¼Œå¤šå€‹æ—¥æœŸè«‹ç”¨<strong>åŠå½¢é€—è™Ÿ</strong>åˆ†éš”ã€‚
              </li>
              <li>ä¾‹å¦‚ï¼š<code>2025-08-01, 2025-09-20</code>ã€‚</li>
              <li>
                è¨­å®šçš„é¡å¤–åœç­æ—¥æœƒè‡ªå‹•å„²å­˜åœ¨ç€è¦½å™¨ä¸­ï¼Œä¸‹æ¬¡é–‹å•Ÿæ™‚å°‡è‡ªå‹•è¼‰å…¥ã€‚
              </li>
            </ul>

            <h4>âœ¨ é–‹å§‹è¨ˆç®—</h4>
            <p>å¡«å¯«å®Œç•¢å¾Œï¼Œé»æ“Šã€Œâœ¨ è¨ˆç®—æ™‚æ•ˆï¼ã€æŒ‰éˆ•ã€‚</p>

            <h4>ğŸ“Š æŸ¥çœ‹çµæœ</h4>
            <ul>
              <li>
                <strong>â± è™•ç†æ™‚æ•¸ï¼š</strong
                >é¡¯ç¤ºç¸½å…±èŠ±è²»çš„ã€Œæ—¥ã€å°æ™‚ã€åˆ†é˜ã€ã€‚æ­¤è™•çš„ã€Œæ—¥ã€ï¼Œä¿‚æŒ‡ 8
                å°æ™‚å·¥ä½œæ—¥çš„æ¦‚å¿µã€‚
              </li>
              <li>
                <strong>ğŸ“… æ›ç®—ç‚ºè™•ç†æ—¥æ•¸ï¼š</strong
                >æ ¹æ“šç‰¹å®šçš„å…¬æ–‡æ™‚æ•ˆè¨ˆç®—è¦å‰‡ï¼ˆä¾‹å¦‚ï¼š1 å°æ™‚æ›ç®—ç‚º 0.12 æ—¥ï¼Œ4
                å°æ™‚æ›ç®—ç‚º 0.50 æ—¥ç­‰ï¼‰è½‰æ›å¾Œçš„æ—¥æ•¸ã€‚
              </li>
              <li>
                <strong>ğŸ•°ï¸ è™•ç†æ™‚æ•¸æ˜ç´°ï¼š</strong
                >åˆ—å‡ºå…¬æ–‡è¾¦ç†æœŸé–“æ¯æ—¥çš„ç‹€æ…‹ï¼ˆå·¥ä½œæ—¥ã€åœ‹å®šå‡æ—¥ã€é¡å¤–åœç­æ—¥ï¼‰åŠè©²æ—¥çš„è™•ç†æ™‚æ•¸ã€‚
                <ul>
                  <li>è‹¥ç‚ºã€Œä¾†æ–‡ã€é¡å‹ï¼Œæ”¶æ–‡ç•¶æ—¥ä¸è¨ˆå…¥è™•ç†æ™‚æ•¸ã€‚</li>
                  <li>
                    å·¥ä½œæ—¥æŒ‰æ¯æ—¥ 08:00ï¼12:00 åŠ 13:00ï¼17:00 è¨ˆç®—å¯¦éš›è™•ç†æ™‚æ•¸ã€‚
                  </li>
                  <li>åœ‹å®šå‡æ—¥åŠé¡å¤–åœç­æ—¥ä¸è¨ˆå…¥è™•ç†æ™‚æ•¸ã€‚</li>
                </ul>
              </li>
            </ul>

            <h4>âš ï¸ æ³¨æ„äº‹é …</h4>
            <ul>
              <li>
                æœ¬è¨ˆç®—å™¨æœƒè‡ªå‹•å˜—è©¦è¼‰å…¥æ”¿åºœè¡Œäº‹æ›†ï¼Œä½†è‹¥ç‰¹å®šå¹´ä»½è³‡æ–™ç„¡æ³•è¼‰å…¥æ™‚ï¼Œè©²å¹´åº¦å°‡åƒ…ä¾é€±æœ«åˆ¤æ–·æ˜¯å¦ç‚ºå·¥ä½œæ—¥ï¼Œè¨ˆç®—çµæœå¯èƒ½æœƒæœ‰å·®ç•°ã€‚
              </li>
              <li>
                è¨ˆç®—è¦å‰‡åŸºæ–¼æ¨™æº–ä¸Šä¸‹ç­æ™‚é–“ï¼ˆ08:00ï¼12:00 åŠ 13:00ï¼17:00ï¼‰ã€‚
              </li>
              <li>æœ¬å·¥å…·åƒ…ä¾›åƒè€ƒï¼Œå¯¦éš›æ™‚æ•ˆèªå®šä»è«‹ä¾å…¬æ–‡ç³»çµ±è¦å®šç‚ºæº–ã€‚</li>
            </ul>
          </div>
          <div class="help-modal-footer">
            <button
              @click="toggleHelpModal(false)"
              class="help-modal-close-button w-full bg-pink-500 hover:bg-pink-600 text-white font-bold py-2.5 px-5 rounded-full shadow-md transition focus:outline-none focus:ring-2 focus:ring-pink-400 focus:ring-opacity-75"
            >
              é—œé–‰èªªæ˜
            </button>
          </div>
        </div>
      </div>
    </div>

    <footer class="text-center text-sm text-gray-400 mt-10 pb-4">
      Â© 2025 å…¬æ–‡æ™‚æ•ˆè¨ˆç®—å™¨ï½œç‰ˆæœ¬è™Ÿ 1.0
    </footer>

    <script>
      const LOCAL_STORAGE_MANUAL_HOLIDAYS_KEY =
        "gongwenCalculator_manualHolidaysInput";
      const CALENDAR_API_BASE_URL =
        "https://raw.githubusercontent.com/ruyut/TaiwanCalendar/master/data/";

      async function fetchCalendarDataForYear(year) {
        const url = `${CALENDAR_API_BASE_URL}${year}.json`;
        try {
          const response = await fetch(url);
          if (!response.ok) {
            console.warn(
              `âš ï¸ ç„¡æ³•è¼‰å…¥ ${year} å¹´æ”¿åºœè¡Œäº‹æ›†è³‡æ–™ (HTTP ${response.status})ã€‚`
            );
            return { success: false, data: [], year: year };
          }
          const rawData = await response.json();
          const processedData = rawData.map((dayInfo) => ({
            date: `${dayInfo.date.slice(0, 4)}-${dayInfo.date.slice(
              4,
              6
            )}-${dayInfo.date.slice(6, 8)}`,
            isHoliday: dayInfo.isHoliday,
            description: dayInfo.description || "",
            week: dayInfo.week || "",
          }));
          return { success: true, data: processedData, year: year };
        } catch (error) {
          console.warn(
            `âš ï¸ è®€å– ${year} å¹´æ”¿åºœè¡Œäº‹æ›†æ™‚ç™¼ç”Ÿç¶²è·¯æˆ–è§£æéŒ¯èª¤: ${error}ã€‚`
          );
          return { success: false, data: [], year: year };
        }
      }

      const app = Vue.createApp({
        data() {
          return {
            formType: "",
            start: "",
            end: "",
            result: null,
            totalHours: 0,
            calendarApiData: {},
            missingYears: [],
            manualHolidayInput: "",
            manualHolidays: [],
            dailyDetails: [],
            initialCalendarLoadAttempted: false,
            showHelpModal: false,
            labels: {
              ä¾†æ–‡å­˜æŸ¥: { start: "æ”¶æ–‡ç™»è¨˜", end: "çµæ¡ˆæ­¸æª”" },
              ä¾†æ–‡å‡½å¾©: { start: "æ”¶æ–‡ç™»è¨˜", end: "é€ç™¼æ–‡äººå“¡ç°½æ”¶" },
              å‰µç°½å­˜æŸ¥: { start: "é€å‡ºæ‰¿è¾¦å–®ä½", end: "çµæ¡ˆæ­¸æª”" },
              å‰µç¨¿ç™¼æ–‡: { start: "é€å‡ºæ‰¿è¾¦å–®ä½", end: "é€ç™¼æ–‡äººå“¡ç°½æ”¶" },
            },
            flatpickrStartInstance: null,
            flatpickrEndInstance: null,
          };
        },
        computed: {
          formattedTime() {
            if (
              this.totalHours === null ||
              this.totalHours === undefined ||
              this.totalHours === 0
            )
              return "0 æ—¥ 0 å°æ™‚ 0 åˆ†é˜";
            const totalMinutes = Math.round(this.totalHours * 60);
            const workDayMinutes = 8 * 60;
            const days = Math.floor(totalMinutes / workDayMinutes);
            const remainingMinutesAfterFullDays = totalMinutes % workDayMinutes;
            const hours = Math.floor(remainingMinutesAfterFullDays / 60);
            const minutes = remainingMinutesAfterFullDays % 60;
            return `${days} æ—¥ ${hours} å°æ™‚ ${minutes} åˆ†é˜`;
          },
        },
        methods: {
          toggleHelpModal(state) {
            this.showHelpModal = state;
          },
          setFormType(type) {
            this.formType = type;
            this.resetFormFields();
            this.$nextTick(() => {
              this.initializeDatePickers();
            });
          },
          resetFormFields() {
            this.start = "";
            this.end = "";
            this.result = null;
            this.totalHours = 0;
            this.dailyDetails = [];
            if (this.flatpickrStartInstance)
              this.flatpickrStartInstance.clear();
            if (this.flatpickrEndInstance) this.flatpickrEndInstance.clear();
          },
          initializeDatePickers() {
            const commonConfig = {
              enableTime: true,
              time_24hr: true,
              dateFormat: "Y-m-d H:i",
              locale: "zh",
            };
            if (this.$refs.startPicker) {
              if (this.flatpickrStartInstance)
                this.flatpickrStartInstance.destroy();
              this.flatpickrStartInstance = flatpickr(this.$refs.startPicker, {
                ...commonConfig,
                onChange: (selectedDates) => {
                  this.start = selectedDates[0]
                    ? selectedDates[0].toISOString()
                    : "";
                },
              });
            }
            if (this.$refs.endPicker) {
              if (this.flatpickrEndInstance)
                this.flatpickrEndInstance.destroy();
              this.flatpickrEndInstance = flatpickr(this.$refs.endPicker, {
                ...commonConfig,
                onChange: (selectedDates) => {
                  this.end = selectedDates[0]
                    ? selectedDates[0].toISOString()
                    : "";
                },
              });
            }
          },
          buttonClass(type) {
            return {
              "bg-pink-500 text-white shadow-md": this.formType === type,
              "bg-pink-100 text-pink-700 hover:bg-pink-200 focus:bg-pink-200 focus:outline-none focus:ring-2 focus:ring-pink-400":
                this.formType !== type,
              "font-semibold py-2.5 px-4 rounded-xl transition-all duration-150 ease-in-out": true,
            };
          },
          detailTypeClass(type) {
            const typeMap = {
              work: "bg-green-100 text-green-800",
              weekend: "bg-gray-200 text-gray-700",
              holiday: "bg-purple-100 text-purple-700",
              manual_holiday: "bg-yellow-100 text-yellow-800",
              info: "bg-indigo-100 text-indigo-700",
              work_no_hours: "bg-blue-100 text-blue-600",
              // For types from getDayClassification that might be used directly for display
              api_workday: "bg-blue-100 text-blue-600", // Could be same as 'info' or 'work_no_hours'
              assumed_workday: "bg-blue-100 text-blue-600", // Could be same as 'info' or 'work_no_hours'
            };
            return typeMap[type] || "bg-gray-50 text-gray-500";
          },
          handleManualHolidayInput() {
            this.parseManualHolidays();
            localStorage.setItem(
              LOCAL_STORAGE_MANUAL_HOLIDAYS_KEY,
              this.manualHolidayInput
            );
          },
          parseManualHolidays() {
            this.manualHolidays = this.manualHolidayInput
              .split(",")
              .map((dateString) => dateString.trim())
              .filter((dateString) => /^\d{4}-\d{2}-\d{2}$/.test(dateString))
              .sort();
          },
          loadManualHolidaysFromStorage() {
            const storedValue = localStorage.getItem(
              LOCAL_STORAGE_MANUAL_HOLIDAYS_KEY
            );
            if (storedValue) {
              this.manualHolidayInput = storedValue;
              this.parseManualHolidays();
            }
          },
          async loadHolidaysForDateRange(startDate, endDate) {
            const startYear = startDate.getFullYear();
            const endYear = endDate.getFullYear();
            const yearsToFetch = new Set();
            for (let year = startYear; year <= endYear; year++) {
              yearsToFetch.add(year);
            }

            const currentMissingYears = new Set(this.missingYears);
            const newCalendarApiData = { ...this.calendarApiData };

            for (const year of yearsToFetch) {
              let yearDataExistsInApi = false;
              for (const dateKey in newCalendarApiData) {
                if (dateKey.startsWith(year.toString())) {
                  yearDataExistsInApi = true;
                  break;
                }
              }

              if (!yearDataExistsInApi && !currentMissingYears.has(year)) {
                const apiResult = await fetchCalendarDataForYear(year);
                if (apiResult.success) {
                  apiResult.data.forEach((dayInfo) => {
                    newCalendarApiData[dayInfo.date] = {
                      isHoliday: dayInfo.isHoliday,
                      description: dayInfo.description,
                      week: dayInfo.week,
                    };
                  });
                } else {
                  currentMissingYears.add(year);
                }
              }
            }
            this.calendarApiData = newCalendarApiData;
            this.missingYears = Array.from(currentMissingYears).sort();
            this.initialCalendarLoadAttempted = true;
          },
          // Helper to classify a day
          getDayClassification(date) {
            const dateStr = this.formatDateToYyyyMmDd(date);
            const apiDayInfo = this.calendarApiData[dateStr];
            const isCurrentYearMissingApiData = this.missingYears.includes(
              date.getFullYear()
            );
            let type, baseReason;

            if (this.isManualHoliday(date)) {
              type = "manual_holiday";
              baseReason = "é¡å¤–åœç­æ—¥";
            } else if (apiDayInfo !== undefined) {
              if (apiDayInfo.isHoliday) {
                type = "holiday";
                baseReason = apiDayInfo.description || "åœ‹å®šå‡æ—¥";
              } else {
                // API says it's a workday
                type = "api_workday"; // Internal type, might become 'work' or 'work_no_hours' later
                baseReason =
                  apiDayInfo.description && apiDayInfo.description.trim() !== ""
                    ? apiDayInfo.description
                    : "ä¸Šç­æ—¥";
              }
            } else if (this.isWeekend(date)) {
              type = "weekend";
              baseReason = `é€±æœ«${
                isCurrentYearMissingApiData
                  ? ` (${date.getFullYear()}å¹´è¡Œäº‹æ›†ç¼ºå¤±)`
                  : ""
              }`;
            } else {
              // Assumed workday
              type = "assumed_workday"; // Internal type
              baseReason = `å·¥ä½œæ—¥${
                isCurrentYearMissingApiData
                  ? ` (${date.getFullYear()}å¹´è¡Œäº‹æ›†ç¼ºå¤±ï¼Œä¾é€±æœ«è¦å‰‡åˆ¤æ–·)`
                  : " (ç„¡è¡Œäº‹æ›†è³‡æ–™ï¼Œä¾é€±æœ«è¦å‰‡åˆ¤æ–·)"
              }`;
            }
            return { type, baseReason, dateStr };
          },
          async calculate() {
            if (!this.start || !this.end) {
              alert("è«‹é¸æ“‡èµ·å§‹å’ŒçµæŸæ™‚é–“ï¼");
              return;
            }
            const initialStartDateTime = new Date(this.start);
            const endDateTime = new Date(this.end);

            if (initialStartDateTime >= endDateTime) {
              alert("çµæŸæ™‚é–“å¿…é ˆæ™šæ–¼èµ·å§‹æ™‚é–“ï¼");
              return;
            }

            this.dailyDetails = [];
            await this.loadHolidaysForDateRange(
              initialStartDateTime,
              endDateTime
            );

            let processingStartDateTime = new Date(initialStartDateTime);

            if (["ä¾†æ–‡å­˜æŸ¥", "ä¾†æ–‡å‡½å¾©"].includes(this.formType)) {
              let loggingDate = new Date(initialStartDateTime);
              loggingDate.setHours(0, 0, 0, 0);

              let actualProcessingDayStartNormalized = this.getNextWorkdayDate(
                new Date(initialStartDateTime)
              );

              while (loggingDate < actualProcessingDayStartNormalized) {
                const classification = this.getDayClassification(loggingDate);
                let displayType = classification.type;
                let displayReason = classification.baseReason;

                const isInitialDay =
                  classification.dateStr ===
                  this.formatDateToYyyyMmDd(initialStartDateTime);
                const reasonSuffix = isInitialDay
                  ? " (æ”¶æ–‡ç•¶æ—¥ï¼Œä¸è¨ˆå…¥è™•ç†æ™‚æ•ˆ)"
                  : " (è™•ç†æ™‚æ•ˆèµ·ç®—å‰)";

                // If it's a potential workday but logged before processing starts, show as 'info'
                if (
                  ["api_workday", "assumed_workday"].includes(
                    classification.type
                  )
                ) {
                  displayType = "info";
                }
                displayReason += reasonSuffix;
                this.dailyDetails.push({
                  date: classification.dateStr,
                  type: displayType,
                  reason: displayReason,
                });
                loggingDate.setDate(loggingDate.getDate() + 1);
                loggingDate.setHours(0, 0, 0, 0);
              }
              processingStartDateTime = new Date(
                actualProcessingDayStartNormalized
              );
              processingStartDateTime.setHours(8, 0, 0, 0);
            }

            if (processingStartDateTime >= endDateTime) {
              this.totalHours = 0;
              const dateForZeroHourLog = this.formatDateToYyyyMmDd(
                processingStartDateTime
              );
              const reasonForZeroHourLog =
                "è¨ˆç®—èµ·å§‹æ™‚é–“å·²æ™šæ–¼æˆ–ç­‰æ–¼çµæŸæ™‚é–“ï¼Œç„¡è™•ç†æ™‚æ•¸ã€‚";
              // Avoid duplicate if already logged by 'ä¾†æ–‡' pre-processing
              if (
                !this.dailyDetails.find(
                  (d) =>
                    d.date === dateForZeroHourLog &&
                    d.reason.includes("ç„¡è™•ç†æ™‚æ•¸")
                )
              ) {
                this.dailyDetails.push({
                  date: dateForZeroHourLog,
                  type: "info",
                  reason: reasonForZeroHourLog,
                });
              }
            } else {
              this.totalHours = this.calculateWorkingHoursAndLogDetails(
                processingStartDateTime,
                endDateTime
              );
            }

            this.result = this.convertHoursToDays(this.totalHours).toFixed(2);
          },
          formatDateToYyyyMmDd(date) {
            const year = date.getFullYear();
            const month = (date.getMonth() + 1).toString().padStart(2, "0");
            const day = date.getDate().toString().padStart(2, "0");
            return `${year}-${month}-${day}`;
          },
          isWeekend(date) {
            const dayOfWeek = date.getDay();
            return dayOfWeek === 0 || dayOfWeek === 6;
          },
          isManualHoliday(date) {
            const dateStr = this.formatDateToYyyyMmDd(date);
            return this.manualHolidays.includes(dateStr);
          },
          isNonWorkday(date) {
            const dateStr = this.formatDateToYyyyMmDd(date);
            if (this.isManualHoliday(date)) return true;

            const apiDayInfo = this.calendarApiData[dateStr];
            if (apiDayInfo !== undefined) return apiDayInfo.isHoliday;

            return this.isWeekend(date);
          },
          getNextWorkdayDate(date) {
            const nextDay = new Date(date);
            nextDay.setDate(nextDay.getDate() + 1);
            nextDay.setHours(0, 0, 0, 0);
            while (this.isNonWorkday(nextDay)) {
              // Before incrementing, log this non-workday if it hasn't been covered by the pre-processing loop in calculate()
              // This logic is tricky because getNextWorkdayDate is also called by the pre-processing loop.
              // For now, assume it's mainly for finding the *first* workday.
              // The main calculate loop will log these days if they fall within range.
              nextDay.setDate(nextDay.getDate() + 1);
            }
            return nextDay;
          },
          calculateWorkingHoursAndLogDetails(startDateTime, endDateTime) {
            let cumulativeWorkHours = 0;
            let currentDayLoop = new Date(startDateTime);
            currentDayLoop.setHours(0, 0, 0, 0);

            const finalDayEndLoopBoundary = new Date(endDateTime);
            finalDayEndLoopBoundary.setHours(23, 59, 59, 999);

            while (currentDayLoop <= finalDayEndLoopBoundary) {
              const classification = this.getDayClassification(currentDayLoop);
              let detailEntry = {
                date: classification.dateStr,
                type: classification.type,
                reason: classification.baseReason,
              };
              let dailyWorkHours = 0;

              if (
                ["manual_holiday", "holiday", "weekend"].includes(
                  classification.type
                )
              ) {
                detailEntry.reason += " (ä¸è¨ˆæ™‚)";
              } else {
                // 'api_workday' or 'assumed_workday'
                const actualSegmentStartForThisDay = new Date(
                  Math.max(startDateTime.getTime(), currentDayLoop.getTime())
                );
                const dayEndBoundaryForCalc = new Date(currentDayLoop);
                dayEndBoundaryForCalc.setHours(23, 59, 59, 999);
                const actualSegmentEndForThisDay = new Date(
                  Math.min(
                    endDateTime.getTime(),
                    dayEndBoundaryForCalc.getTime()
                  )
                );

                if (actualSegmentStartForThisDay < actualSegmentEndForThisDay) {
                  const morningWorkStart = new Date(currentDayLoop);
                  morningWorkStart.setHours(8, 0, 0, 0);
                  const morningWorkEnd = new Date(currentDayLoop);
                  morningWorkEnd.setHours(12, 0, 0, 0);
                  const afternoonWorkStart = new Date(currentDayLoop);
                  afternoonWorkStart.setHours(13, 0, 0, 0);
                  const afternoonWorkEnd = new Date(currentDayLoop);
                  afternoonWorkEnd.setHours(17, 0, 0, 0);

                  dailyWorkHours += this.getOverlapHours(
                    actualSegmentStartForThisDay,
                    actualSegmentEndForThisDay,
                    morningWorkStart,
                    morningWorkEnd
                  );
                  dailyWorkHours += this.getOverlapHours(
                    actualSegmentStartForThisDay,
                    actualSegmentEndForThisDay,
                    afternoonWorkStart,
                    afternoonWorkEnd
                  );
                }

                if (dailyWorkHours > 0) {
                  cumulativeWorkHours += dailyWorkHours;
                  const dailyTotalMinutes = Math.round(dailyWorkHours * 60);
                  const dailyH = Math.floor(dailyTotalMinutes / 60);
                  const dailyM = dailyTotalMinutes % 60;
                  detailEntry.type = "work"; // Final display type
                  detailEntry.reason = `${classification.baseReason}ï¼Œè™•ç† ${dailyH} å°æ™‚ ${dailyM} åˆ†é˜`;
                } else {
                  detailEntry.type = "work_no_hours"; // Final display type
                  detailEntry.reason = `${classification.baseReason}ï¼Œä½†ç„¡ç¬¦åˆè¨ˆç®—çš„æ™‚æ®µæˆ–æ™‚æ•¸ç‚ºé›¶`;
                }
              }
              this.dailyDetails.push(detailEntry);
              currentDayLoop.setDate(currentDayLoop.getDate() + 1);
              currentDayLoop.setHours(0, 0, 0, 0);
            }
            return cumulativeWorkHours;
          },
          getOverlapHours(
            segment1Start,
            segment1End,
            segment2Start,
            segment2End
          ) {
            const overlapStart = Math.max(
              segment1Start.getTime(),
              segment2Start.getTime()
            );
            const overlapEnd = Math.min(
              segment1End.getTime(),
              segment2End.getTime()
            );
            const diffMillis = overlapEnd - overlapStart;
            return diffMillis > 0 ? diffMillis / (1000 * 60 * 60) : 0;
          },
          convertHoursToDays(hoursToConvert) {
            if (hoursToConvert <= 0) return 0.0;

            const HOURS_PER_WORKDAY = 8;
            const fullDays = Math.floor(hoursToConvert / HOURS_PER_WORKDAY);
            const remainingHoursOnly = hoursToConvert % HOURS_PER_WORKDAY;
            let fractionalDays = 0;

            if (remainingHoursOnly > 0) {
              if (remainingHoursOnly < 1) {
                fractionalDays = 0.1;
              } else {
                const flooredRemainingHours = Math.floor(remainingHoursOnly);
                const conversionTable = {
                  1: 0.12,
                  2: 0.25,
                  3: 0.38,
                  4: 0.5,
                  5: 0.62,
                  6: 0.75,
                  7: 0.88,
                };
                fractionalDays = conversionTable[flooredRemainingHours] || 0;
              }
            }
            return fullDays + fractionalDays;
          },
        },
        mounted() {
          this.loadManualHolidaysFromStorage();
        },
      });
      app.mount("#app");
    </script>
  </body>
</html>
